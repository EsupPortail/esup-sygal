# Version 7.1.0

## 1. Sur le serveur d'application

- Placez-vous dans le répertoire de l'application puis lancez la commande suivante
  pour installer la nouvelle version :

  ```bash
  git fetch --tags && git checkout --force 7.1.0 && bash ./install.sh
  ```

- Rechargez le moteur PHP, exemple :

  ```bash
  systemctl reload php8.0-fpm
  ```

## 2. Dans la base de données

```postgresql
--
-- Restauration des valeurs originales de clés étrangères :
-- modif pour n'afficher une notice qu'en cas de remplacements faits (et pas systématiquement).
--
create or replace function substit_restore_foreign_key_value(p_type varchar, p_tab_name varchar, p_col_name varchar, p_from_id bigint, p_to_id bigint) returns int
    language plpgsql
as
$$declare
    v_id record;
    v_count int = 0;
    v_message text;
    v_fkr substit_fk_replacement;
begin
    --
    -- Restauration de la valeur de la clé étrangère originale dans une table.
    --

    v_message = format('Restaurations FK %s.%s %s => %s :', upper(p_tab_name), p_col_name, p_to_id, p_from_id);

    for v_fkr in
        select * from substit_fk_replacement
                 where type = p_type and table_name = p_tab_name and column_name = p_col_name
                   and from_id = p_from_id and to_id = p_to_id
    loop
        for v_id in execute format('update %I set %I = %s where id = %s and %I = %s returning id',
            p_tab_name, p_col_name, p_from_id, v_fkr.record_id, p_col_name, p_to_id)
        loop
            v_count = v_count + 1;
            perform substit_insert_log(p_type, 'FK_RESTORE', p_from_id, p_to_id, null, v_message||' '||v_id);
        end loop;
    end loop;
    if v_count > 0 then
        delete from substit_fk_replacement
            where type = p_type and table_name = p_tab_name and column_name = p_col_name and from_id = p_from_id and to_id = p_to_id;
        raise notice '% % faites.', v_message, v_count;
    end if;

    return v_count;
end
$$;

--
-- Modification de la fonction de suppression d'une substitution 'individu' :
-- en cas d'échec de la suppression du substituant à cause d'une contrainte d'intégrité (i.e. il est référencé
-- dans d'autres tables) :
--   - dans le cas où il ne reste qu'1 substitué dans la substitution on remplace partout l'id du substituant
--     par celui du dernier substitué, ce qui nous permettra ensuite de procéder à la suppression prévue.
--   - sinon, on logue simplement le problème.
--
create or replace function substit_delete_substitution(type character varying, p_substituant_id bigint) returns void
  language plpgsql
as
$$declare
  v_count int;
  v_message text;
  v_stack text;
  v_substit record;
begin
  --
  -- Supprime une substitution, spécifiée par l'enregistrement substituant.
  --

  raise notice 'Suppression du substituant % et de la substitution associée...', p_substituant_id;

  execute format('select count(*) from substit_%s where to_id = %s', type, p_substituant_id) into v_count;

  begin
    -- NB : la suppression déclenche le trigger de la table 'substit_%s'
    execute format('delete from substit_%s where to_id = %s', type, p_substituant_id);
    perform substit_insert_log(type, 'SUBSTITUTION_SUPPR', null, p_substituant_id, null,
                               format('Suppression des %s substitutions par %s', v_count, p_substituant_id));

    execute format('delete from %I where id = %s', type, p_substituant_id);
    perform substit_insert_log(type, 'SUBSTITUANT_SUPPR', null, p_substituant_id, null,
                               format('Suppression du substituant %s', p_substituant_id));

  exception WHEN integrity_constraint_violation THEN
    -- échec de la suppression du substituant à cause d'une contrainte d'intégrité (i.e. il est référencé
    -- dans d'autres tables) : cela annule tout ce qui est entre `begin` et `exception`.
    v_message = format('Suppression du substituant %s impossible car il est utilisé dans au moins une table ' ||
                       '(contrainte d''intégrité) : %L', p_substituant_id, v_stack);
    raise notice '%', v_message;

    if v_count = 1 then
      -- dans le cas où il ne reste qu'1 substitué dans la substitution on remplace partout l'id du substituant
      -- par celui du dernier substitué, ce qui nous permettra ensuite de procéder à la suppression prévue.
      raise notice 'Un seul substitué restant donc remplacement de l''id du substituant par l''id du substitué...';
      -- remplacement de l'id du substituant par l'id du dernier substitué restant
      execute format('select * from substit_%s where to_id = %s limit 1', type, p_substituant_id) into v_substit;
      select substit_replace_foreign_keys_values(type, p_substituant_id, v_substit.from_id) into v_count;
      -- ensuite on peut supprimer le substituant
      perform substit_delete_substitution(type, p_substituant_id);
    else
      -- sinon, on logue simplement le problème.
      GET STACKED DIAGNOSTICS v_stack = MESSAGE_TEXT;
      perform substit_insert_log(type, 'SUBSTITUANT_SUPPR_PROBLEM', null, p_substituant_id, null, v_message);
    end if;
  end;

  raise notice '=> Terminé.';
end
$$;


```
